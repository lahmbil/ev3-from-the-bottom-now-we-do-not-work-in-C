# An EV3 Mindstorms puck grabber

![](doc/html/swagboy.png)



Swagboy-C is a puck grabber robot for my bachelor's degree's introductory course to artificial intelligence. Equipped with 2 wheels, powered by 2 EV3 large motors, 1 claw, powered by 1 EV3 medium motor, 1 ultrasonic sensor, 1 touch sensor and 1 color sensor.



Against another robot, its aim is to grab the largest number of pucks and to put them into the other robot's goal, in a fixed amount of time.



Swagboy is written in C, and uses [EV3Dev](https://www.ev3dev.org/) (Stretch Snapshot 12012018) and [EV3Dev-c](http://in4lio.github.io/ev3dev-c/).

The choice to switch from Java to C was done at the last minute and as such everything was not thoroughly tested.


Tell your EV3 I said hi!

This documentation was generated by Doxygen.



## Structure

This project can be split into 5 modules:

- Wheels
- Claw
- Sensors
- Pathfinding
- Controller



**Wheels** manages the wheels and the 2 large motors. EV3Dev-c being a crude library, this module abstracts a lot of basic movements like traveling a certain distance or rotating. It also calculates the position of the robot on the field. This feature is only assured to work if the speed is set to 30% of the maximum.
It can also navigate on  a field filled with obstacles, using **Pathfinding**. The config file is not yet implemented, so if you wish to use this program on your robot, you either need to modify the sources and recompile them or change the ports used by your robot: left motor *A*, right motor *B*, medium motor *D*.

**Pathfinding** uses the A* implementation of [libastar](https://www.bedroomlan.org/projects/libastar/). The project was rewritten near the end of the deadline, and there was not enough time to write our own implementation. This library uses a GPL licensing and so this project falls under this license while using it. There are not a lot of library for pathfinding in C.

**Claw** manages the claw of the robot: initialization, opening, and closing are the operations supported.

**Sensors** manages all the sensors of the robot. Call init_sensors() once and start to call get_distance(), get_color() and is_pressed(). The ports are written in the source file directly so if you wish to use this program on your robot, make sure to recompile the sources or to set the sensors to the same ports as us: sonic sensor *S1*, color sensor *S2* and touch sensor *S3*. Next release should introduce a config file. 

**Controller** manages all the logic and decision making of the robot. You only need to call controller() in your main function.



## Development

EV3Dev-C is built on top of EV3Dev Jessie. EV3Dev Stretch introduced some breaking changes, like port naming. If you wish to compile the sources, your first need to modify ev3_port.c and ev3_both.h and to recompile EV3Dev-C.



In the function ev3_parse_port_name in ev3_port.c:

```c
*port = EV3_PORT__NONE;
*extport = EV3_PORT__NONE;
*addr = 0;

char* platform_prefix = strchr(name, ':');
if (platform_prefix)
    name = platform_prefix + 1;
```



In the header ev3_both.h, the correct GPIO_KEYS_PATH:

```c
#define GPIO_KEYS_PATH "/dev/input/by-path/platform-gpio_keys-event"
```



In libastar, astar_heap.h:

```c
inline void
astar_heap_clear (asheap_t * heap) {

	assert(heap != NULL);
	heap->length = 0;
}
```

And astar.h, add the following definition:

```c
void astar_destroy (astar_t * as);
```





The project is cross compiled with Docker (see: https://github.com/in4lio/ev3dev-c/tree/master/docker). Once you have your image of ev3dev/debian-stretch-cross ready, by making some small changes to *script.sh*, you can easily compile and launch the program.

In any case, do not compile with the makefile generated by cmake. We only use it to tell our IDE where the sources are for the autocompletion.



We suppose libastar's sources are located inside an "astar" directory, inside the ev3 sources folder.



EV3Dev Stretch fixes a lot of bugs, such as the color space of the color sensor, which could only previously detect 2 colors in our use case, and adds a bit of motor synchronization.



## Known bugs



We suspect some memory leaks. Valgrind is not available for our architecture. [Memwatch](http://memwatch.sourceforge.net/) is not detecting anything strange, but the **free** command used before launching the program, and after, shows us that all the memory is not freed.
